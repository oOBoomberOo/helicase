1) function
definition:
```
fn identifier($($parameter: type)*) -> identifier {...}
```

```
fn function_name(parameter: type) -> entity {...}
```

features:
- You can call this function from anywhere.
- You can refer to @s via `self` keyword

2) trait
definition:
```
trait identifier {
	nbt = {...};

	$(
		$identifier: function
	)*
}
```
```
#[derive($($x: trait)*)]
summon pig ~ ~ ~
```
```
execute as @e[trait=($x: trait)] run ...
```

features:
- Will be refer to /tag when compiled
- Will be able to refer to function inside trait via `.` keyword

3) import
definition:
```
use "../path/to/definition";
use "/absolute/path/to/definition";
use "/path/to/namespace";

namespace::function(do_something);
```

4) scoreboard
```
let $name: identifier = $value: expression;
```
```
declare Bar dummy {"text": "Bar Scoreboard", "italic": true};
let bar: Bar = 50;

scoreboard players operation @s = bar
```
```
scoreboard players operation @s dummy /= 5
```

```
enum $enum_name: identifier {
	$(
		$name: identifier
	)*
}
```
```
enum Foo {
	StateA,
	StateB,
	StateC
}

let a = Foo.StateA;
let b = Foo.StateB;
let c = Foo.StateC;

enum Foo: objective {...}
```

features:
- Objective name will be generate at compiled time unless specify so
- Math operation with just number
- scoreboard operation will be done on the same objective unless specify so

5) pack.meta
```
name: Datapack Name
version: 0.1.0
description: Datapack description
custom_model_base: 8080000
```

usage:
```
// declare "boomber:stringly_type_model_id" in resourcepack module

give @s diamond{custom_model_id: ${boomber:stringly_type_model_id}}
```
```
tellraw @s "Datapack Version: ${version}"
```