use std::str::FromStr;
use crate::parser::ast::{*};

grammar;

pub statements: Vec<Statement> = {
	"{" <statements> "}",
	<statement*>
};

pub statement: Statement = {
	<atr:attribute> <stm:statement> => Statement::Attribute(atr, Box::from(stm)),
	function_declaration => Statement::FunctionDeclaration(<>),
	trait_declaration => Statement::TraitDeclaration(<>),
	"var" <ident> "=" <expression> ";" => Statement::Declare(<>),
	<expression> ";" => Statement::Expression(<>),
	";" => Statement::None
};

expression: Expression = {
	number => Expression::Number(<>),
	literal => Expression::Literal(<>),
	ident => Expression::Ident(<>),
	"(" <expression> ")" => Expression::Expression(Box::new(<>))
};

float: f32 = r"[0-9\-.]+f" => f32::from_str(pop_string(<>)).unwrap();
double: f64 = r"[0-9\-.]+d" => f64::from_str(pop_string(<>)).unwrap();
byte: i8 = r"[0-9\-]+b" => i8::from_str(pop_string(<>)).unwrap();
short: i16 = r"[0-9\-]+s" => i16::from_str(pop_string(<>)).unwrap();
long: i64 = r"[0-9\-]+L" => i64::from_str(pop_string(<>)).unwrap();
number: i32 = r"[0-9\-]+" => i32::from_str(<>).unwrap();
boolean: bool = { "true" => true, "false" => false }

ident: Identifier = r"[a-zA-Z_]+" => <>.to_string();
literal: String = r#""(\\.|[^\\"])*""# => <>.to_string();

trait_declaration: TraitDeclaration = {
	"trait" <name:ident> "{" <inner:trait_inner> "}" => TraitDeclaration::new(name, inner),
	"trait" <name:ident> ";" => TraitDeclaration::new(name, TraitInner::default())
};

trait_inner: TraitInner = {
	"nbt" "=" <n:nbt> <f:(function_declaration)*> => TraitInner::new(Some(n), f),
	<f:(function_declaration)*> => TraitInner::new(None, f)
};

function_declaration: FunctionDeclaration = {
	"fn" <name:ident> "(" <parameters:(<parameter> ",")*> <extra:parameter?> ")" "{" <content:statements> "}" => {
		let mut parameters = parameters;
		if let Some(extra) = extra {
			parameters.push(extra);
		}

		FunctionDeclaration::new(name, parameters, content)
	}
};

parameter: Parameter = {
	<name:ident> ":" <kind:ident> => Parameter::new(name, kind)
}

nbt: Nbt = {
	"{" <v:(<ident> ":" <nbt>)*> "}" => Nbt::new_compound(v),
	"[" <v:(<nbt> ",")*> <extra:nbt?> "]" => {
		let mut list = v;
		if let Some(extra) = extra {
			list.push(extra);
		}
		Nbt::new_list(list)
	},
	literal => Nbt::new_literal(<>),
	float => Nbt::new_float(<>),
	double => Nbt::new_double(<>),
	byte => Nbt::new_byte(<>),
	short => Nbt::new_short(<>),
	number => Nbt::new_integer(<>),
	long => Nbt::new_long(<>),
	boolean => Nbt::new_boolean(<>),
}

attribute: Attribute = {
	"#[" <v:(<ident> ",")*> <extra:ident?> "]" => {
		let mut values = v;
		if let Some(extra) = extra {
			values.push(extra);
		}
		Attribute::new(values)
	}
}