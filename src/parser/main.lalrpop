use std::str::FromStr;
use crate::parser::ast::*;

grammar;

pub statements: Vec<Statement> = {
	"{" <statements> "}",
	<statement*>
};

pub statement: Statement = {
	<atr:attribute> <stm:statement> => Statement::Attribute(atr, Box::from(stm)),
	function_declaration => Statement::FunctionDeclaration(<>),
	trait_declaration => Statement::TraitDeclaration(<>),
	enum_declaration => Statement::EnumDeclaration(<>),
	scoreboard_declaration => Statement::ScoreboardDeclaration(<>),
	function_call => Statement::FunctionCall(<>),
	<expression> ";" => Statement::Expression(<>),
	<ident> "=" <expression> ";" => Statement::Assign(<>),
	"let" <name:ident> "=" <value:expression> ";" => Statement::Declare(name, None, value),
	"let" <name:ident> ":" <kind:ident> "=" <value:expression> ";" => Statement::Declare(name, Some(kind), value),
	"use" <literal> ";" => Statement::Import(<>),
	";" => Statement::None
};

operation: Operation = {
	"%" => Operation::Mod,
	"/" => Operation::Div,
	"*" => Operation::Mul,
	"-" => Operation::Sub,
	"+" => Operation::Add,
};

expression: Expression = {
	number => Expression::Number(<>),
	literal => Expression::Literal(<>),
	ident => Expression::Ident(<>),
	<a:expression> "." <b:ident> => Expression::Access(Box::from(a), Box::from(b)),
	<a:expression> <b:operation> <c:term> => Expression::Operation(Box::from(a), b, Box::from(c)),
	"(" <expression> ")" => <>
};

term: Expression = {
	"(" <expression> ")",
	number => Expression::Number(<>),
	literal => Expression::Literal(<>),
	ident => Expression::Ident(<>),
}

float: f32 = r"[0-9\-.]+f" => f32::from_str(pop_string(<>)).unwrap();
double: f64 = r"[0-9\-.]+d" => f64::from_str(pop_string(<>)).unwrap();
byte: i8 = r"[0-9\-]+b" => i8::from_str(pop_string(<>)).unwrap();
short: i16 = r"[0-9\-]+s" => i16::from_str(pop_string(<>)).unwrap();
long: i64 = r"[0-9\-]+L" => i64::from_str(pop_string(<>)).unwrap();
number: i32 = r"[0-9\-]+" => i32::from_str(<>).unwrap();
boolean: bool = { "true" => true, "false" => false }

ident: Identifier = r"([a-zA-Z_]|::)+" => <>.to_string();
literal: String = r#""(\\.|[^\\"])*""# => <>.to_string();

trait_declaration: TraitDeclaration = {
	"trait" <name:ident> "{" <inner:trait_inner> "}" => TraitDeclaration::new(name, inner),
	"trait" <name:ident> ";" => TraitDeclaration::new(name, TraitInner::default())
};

trait_inner: TraitInner = {
	"nbt" "=" <n:nbt> <f:(function_declaration)*> => TraitInner::new(Some(n), f),
	<f:(function_declaration)*> => TraitInner::new(None, f)
};

function_declaration: FunctionDeclaration = {
	"fn" <name:ident> "(" <parameters:(<parameter_declration> ",")*> <extra:parameter_declration?> ")" "->" <return_type:ident> "{" <content:statements> "}" => {
		let mut parameters = parameters;
		if let Some(extra) = extra {
			parameters.push(extra);
		}

		FunctionDeclaration::new(name, parameters, content, None)
	},
	"fn" <name:ident> "(" <parameters:(<parameter_declration> ",")*> <extra:parameter_declration?> ")" "{" <content:statements> "}" => {
		let mut parameters = parameters;
		if let Some(extra) = extra {
			parameters.push(extra);
		}

		FunctionDeclaration::new(name, parameters, content, None)
	}
};

parameter_declration: ParameterDeclaration = <name:ident> ":" <kind:ident> => ParameterDeclaration::new(name, kind);

nbt: Nbt = {
	"{" <v:(<ident> ":" <nbt> ",")*> <extra:(<ident> ":" <nbt>)?> "}" => {
		let mut list = v;
		if let Some(extra) = extra {
			list.push(extra);
		}
		Nbt::new_compound(list)
	},
	"[" <v:(<nbt> ",")*> <extra:nbt?> "]" => {
		let mut list = v;
		if let Some(extra) = extra {
			list.push(extra);
		}
		Nbt::new_list(list)
	},
	literal => Nbt::new_literal(<>),
	float => Nbt::new_float(<>),
	double => Nbt::new_double(<>),
	byte => Nbt::new_byte(<>),
	short => Nbt::new_short(<>),
	number => Nbt::new_integer(<>),
	long => Nbt::new_long(<>),
	boolean => Nbt::new_boolean(<>),
}

attribute: Attribute = {
	"#[" <v:(<ident> ",")*> <extra:ident?> "]" => {
		let mut values = v;
		if let Some(extra) = extra {
			values.push(extra);
		}
		Attribute::new(values)
	}
}

enum_declaration: EnumDeclaration = "enum" <name:ident> "{" <v:(<ident> ",")*> <extra:ident?> "}" => {
	let mut list = v;
	if let Some(extra) = extra {
		list.push(extra);
	}
	EnumDeclaration::new(name, list)
};

function_call: FunctionCall = <name:ident> "(" <v:(<expression> ",")*> <extra:expression?> ")" => {
	let mut list = v;
	if let Some(extra) = extra {
		list.push(extra);
	}

	FunctionCall::new(name, list)
};

scoreboard_name: String = {
	ident,
	<a:ident> "." <b:scoreboard_name> => format!("{}.{}", a, b),
	<a:ident> ":" <b:scoreboard_name> => format!("{}:{}", a, b),
};

scoreboard_declaration: ScoreboardDeclaration = {
	"declare" <name:scoreboard_name> <objective:scoreboard_name> ";" => ScoreboardDeclaration::new(name, objective, None),
	"declare" <name:scoreboard_name> <objective:scoreboard_name> <display_name:nbt> ";" => ScoreboardDeclaration::new(name, objective, Some(display_name)),
};